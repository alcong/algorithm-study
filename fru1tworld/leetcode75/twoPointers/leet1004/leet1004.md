## 문제

[1004](https://leetcode.com/problems/max-consecutive-ones-iii/?envType=study-plan-v2&envId=leetcode-75)

## 해결 방법

- l,r을 두고 r을 0부터 n까지 순회합니다.
- 만약 원소가 0이라면 k를 감소시킵니다.
- k의 길이가 0 이하로 떨어지면 1 - nums[l]을 더합니다.
- 이후 l을 1 증가시킵니다.

- 예제 1로 살펴보겠습니다.
- nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2

- [1,1,1 ] 까지는 k가 감소하지 않고
- [1,1,1,0] 부터 k가 감소하여
- [1,1,1,0,0] 까지 도달합니다 이때 길이는 5입니다.
- [1,1,0,0,0] 부터는 k가 -1가 되므로 l을 증가시킵니다.
- 그러나 k는 여전히 -1이 입니다.

- [0,0,1,1,1]에 도달하면 k는 다시 0이 됩니다.
- [0,0,1,1,1,1]로 증가하게 됩니다.
- [0,1,1,1,1,0]로 가게 됩니다.

- 이 문제의 알고리즘 정당성은 다음과 같습니다.
- 투 포인터로 길이가 절대 감소하지 않고 최대 길이를 찾게 되면 길이가 유지됩니다.
- 이때 길이를 늘리는 방법은 k >= 0 일 때 r을 증가시키고
- k < 0 이면 l도 증가시켜서 길이를 유지시킵니다.

```
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int l=0, r;
        int n = nums.size();
        for(r=0; r<n; r++){
            if(nums[r] == 0) k--;
            if(k<0) k += 1 - nums[l++];
        }
        return r-l;
    }
};
```
